// AI Bot Service - Generates intelligent, varied bot strategies
// Can connect to Claude API or use local heuristics as fallback

import { ModuleType, SecurityModule, SecurityLoadout, BotSafe } from '../types';
import { MODULE_CONFIG, BOT_NAMES, ECONOMY } from '../game/constants';
import {
  calculateSecurityScore,
  calculateAttackFee,
  getDifficultyBand,
  getLootRange,
  getSuccessChanceLabel,
  calculateSuccessProbability,
} from '../game/economy';

// Bot personality archetypes that influence strategy
export type BotPersonality =
  | 'aggressive'    // High risk, high reward - brutal locks, rich vaults
  | 'defensive'     // Maximum security, lower balance
  | 'balanced'      // Mixed approach
  | 'trickster'     // Unusual game combinations to surprise attackers
  | 'minimalist'    // Simple, classic locks only
  | 'arcade_master' // Heavy focus on arcade games
  | 'puzzle_expert' // Loves puzzle challenges
  | 'chaos'         // Random, unpredictable choices
  | 'meta_gamer';   // Uses currently "strong" combinations

// Strategy profile generated by AI
export interface BotStrategy {
  personality: BotPersonality;
  name: string;
  tagline: string;
  preferredModuleTypes: ModuleType[];
  difficultyPreference: 'easy' | 'medium' | 'hard' | 'varied';
  wealthLevel: 'poor' | 'moderate' | 'wealthy';
  reasoning?: string;
}

// AI service configuration
interface AIServiceConfig {
  apiKey?: string;
  apiEndpoint?: string;
  model?: string;
  useLocalFallback: boolean;
  cacheResponses: boolean;
  cacheDuration: number; // ms
}

const DEFAULT_CONFIG: AIServiceConfig = {
  useLocalFallback: true,
  cacheResponses: true,
  cacheDuration: 5 * 60 * 1000, // 5 minutes
};

// Get all available module types by category
const MODULE_TYPES_BY_CATEGORY = {
  classic: ['pattern', 'keypad', 'timing', 'combination', 'sequence', 'slider', 'rotation', 'wire', 'fingerprint', 'morse', 'colorcode', 'safedial'] as ModuleType[],
  arcade: ['pacman', 'spaceinvaders', 'frogger', 'donkeykong', 'centipede', 'asteroids', 'snake', 'breakout', 'tetris', 'galaga', 'digdug', 'qbert'] as ModuleType[],
  puzzle: ['quickmath', 'wordscramble', 'memorymatch', 'sudoku', 'jigsaw', 'wordsearch', 'logic', 'maze', 'spotdiff', 'reaction', 'numsequence', 'cipher'] as ModuleType[],
};

const ALL_MODULE_TYPES = [
  ...MODULE_TYPES_BY_CATEGORY.classic,
  ...MODULE_TYPES_BY_CATEGORY.arcade,
  ...MODULE_TYPES_BY_CATEGORY.puzzle,
];

// Personality-based strategy templates
const PERSONALITY_TEMPLATES: Record<BotPersonality, Partial<BotStrategy>> = {
  aggressive: {
    difficultyPreference: 'hard',
    wealthLevel: 'wealthy',
    tagline: 'Come at me if you dare',
  },
  defensive: {
    difficultyPreference: 'hard',
    wealthLevel: 'moderate',
    tagline: 'Fort Knox has nothing on me',
  },
  balanced: {
    difficultyPreference: 'medium',
    wealthLevel: 'moderate',
    tagline: 'All things in moderation',
  },
  trickster: {
    difficultyPreference: 'varied',
    wealthLevel: 'moderate',
    tagline: 'Expect the unexpected',
  },
  minimalist: {
    difficultyPreference: 'medium',
    wealthLevel: 'poor',
    tagline: 'Simple but effective',
  },
  arcade_master: {
    difficultyPreference: 'hard',
    wealthLevel: 'moderate',
    tagline: 'Game over, man!',
  },
  puzzle_expert: {
    difficultyPreference: 'hard',
    wealthLevel: 'moderate',
    tagline: 'Think you can outsmart me?',
  },
  chaos: {
    difficultyPreference: 'varied',
    wealthLevel: 'moderate',
    tagline: 'Pure randomness',
  },
  meta_gamer: {
    difficultyPreference: 'hard',
    wealthLevel: 'wealthy',
    tagline: 'Playing the meta',
  },
};

// Current meta - which games are considered "strong" (hard for attackers)
const CURRENT_META_GAMES: ModuleType[] = ['safedial', 'tetris', 'sudoku', 'morse', 'galaga', 'cipher'];

class AIBotService {
  private config: AIServiceConfig;
  private strategyCache: Map<string, { strategy: BotStrategy; timestamp: number }> = new Map();

  constructor(config: Partial<AIServiceConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  // Configure API settings
  configure(config: Partial<AIServiceConfig>): void {
    this.config = { ...this.config, ...config };
  }

  // Generate a strategy using AI API or fallback
  async generateStrategy(
    playerRating: number,
    context?: { recentAttacks?: string[]; playerLoadout?: ModuleType[] }
  ): Promise<BotStrategy> {
    const cacheKey = `strategy-${playerRating}-${JSON.stringify(context)}`;

    // Check cache
    if (this.config.cacheResponses) {
      const cached = this.strategyCache.get(cacheKey);
      if (cached && Date.now() - cached.timestamp < this.config.cacheDuration) {
        return cached.strategy;
      }
    }

    let strategy: BotStrategy;

    // Try AI API if configured
    if (this.config.apiKey && this.config.apiEndpoint) {
      try {
        strategy = await this.callAIAPI(playerRating, context);
      } catch (error) {
        console.warn('AI API call failed, using fallback:', error);
        strategy = this.generateLocalStrategy(playerRating, context);
      }
    } else {
      strategy = this.generateLocalStrategy(playerRating, context);
    }

    // Cache result
    if (this.config.cacheResponses) {
      this.strategyCache.set(cacheKey, { strategy, timestamp: Date.now() });
    }

    return strategy;
  }

  // Call external AI API (Claude, OpenAI, etc.)
  private async callAIAPI(
    playerRating: number,
    context?: { recentAttacks?: string[]; playerLoadout?: ModuleType[] }
  ): Promise<BotStrategy> {
    const prompt = this.buildPrompt(playerRating, context);

    const response = await fetch(this.config.apiEndpoint!, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.config.apiKey}`,
        'anthropic-version': '2023-06-01',
      },
      body: JSON.stringify({
        model: this.config.model || 'claude-3-haiku-20240307',
        max_tokens: 500,
        messages: [
          {
            role: 'user',
            content: prompt,
          },
        ],
      }),
    });

    if (!response.ok) {
      throw new Error(`API request failed: ${response.statusText}`);
    }

    const data = await response.json();
    return this.parseAIResponse(data);
  }

  // Build prompt for AI
  private buildPrompt(
    playerRating: number,
    context?: { recentAttacks?: string[]; playerLoadout?: ModuleType[] }
  ): string {
    return `You are a strategic AI for a heist game where players attack each other's safes protected by mini-games.

Available security games (36 total):
- CLASSIC LOCKS: pattern, keypad, timing, combination, sequence, slider, rotation, wire, fingerprint, morse, colorcode, safedial
- ARCADE GAMES: pacman, spaceinvaders, frogger, donkeykong, centipede, asteroids, snake, breakout, tetris, galaga, digdug, qbert
- PUZZLE GAMES: quickmath, wordscramble, memorymatch, sudoku, jigsaw, wordsearch, logic, maze, spotdiff, reaction, numsequence, cipher

Current meta (considered strong): ${CURRENT_META_GAMES.join(', ')}

Player rating: ${playerRating}
${context?.recentAttacks ? `Recent attack patterns: ${context.recentAttacks.join(', ')}` : ''}
${context?.playerLoadout ? `Player's own loadout uses: ${context.playerLoadout.join(', ')}` : ''}

Generate a bot strategy as JSON with these fields:
- personality: one of [aggressive, defensive, balanced, trickster, minimalist, arcade_master, puzzle_expert, chaos, meta_gamer]
- preferredModuleTypes: array of exactly 3 game types to use
- difficultyPreference: one of [easy, medium, hard, varied]
- wealthLevel: one of [poor, moderate, wealthy]
- reasoning: brief explanation of the strategy

Respond with ONLY valid JSON, no other text.`;
  }

  // Parse AI response into strategy
  private parseAIResponse(data: any): BotStrategy {
    try {
      const content = data.content?.[0]?.text || data.choices?.[0]?.message?.content;
      const parsed = JSON.parse(content);

      return {
        personality: parsed.personality || 'balanced',
        name: this.generateName(parsed.personality),
        tagline: PERSONALITY_TEMPLATES[parsed.personality as BotPersonality]?.tagline || 'Ready for action',
        preferredModuleTypes: parsed.preferredModuleTypes?.slice(0, 3) || ['pattern', 'keypad', 'timing'],
        difficultyPreference: parsed.difficultyPreference || 'medium',
        wealthLevel: parsed.wealthLevel || 'moderate',
        reasoning: parsed.reasoning,
      };
    } catch {
      // Fallback if parsing fails
      return this.generateLocalStrategy(1000);
    }
  }

  // Generate strategy using local heuristics (no API needed)
  generateLocalStrategy(
    playerRating: number,
    context?: { recentAttacks?: string[]; playerLoadout?: ModuleType[] }
  ): BotStrategy {
    // Pick a random personality with weighted distribution
    const personality = this.pickPersonality(playerRating);
    const template = PERSONALITY_TEMPLATES[personality];

    // Select module types based on personality
    const preferredModuleTypes = this.selectModulesForPersonality(personality, context);

    return {
      personality,
      name: this.generateName(personality),
      tagline: template.tagline || 'Ready for battle',
      preferredModuleTypes,
      difficultyPreference: template.difficultyPreference || 'medium',
      wealthLevel: template.wealthLevel || 'moderate',
    };
  }

  // Pick personality based on player rating and randomness
  private pickPersonality(playerRating: number): BotPersonality {
    const personalities: BotPersonality[] = [
      'aggressive', 'defensive', 'balanced', 'trickster',
      'minimalist', 'arcade_master', 'puzzle_expert', 'chaos', 'meta_gamer'
    ];

    // Weight certain personalities based on player rating
    const weights: number[] = personalities.map(p => {
      if (playerRating > 1200) {
        // Higher rated players face more meta_gamers and defensive
        if (p === 'meta_gamer' || p === 'defensive') return 2;
      }
      if (playerRating < 800) {
        // Lower rated players face more balanced and minimalist
        if (p === 'balanced' || p === 'minimalist') return 2;
      }
      return 1;
    });

    // Weighted random selection
    const totalWeight = weights.reduce((a, b) => a + b, 0);
    let random = Math.random() * totalWeight;

    for (let i = 0; i < personalities.length; i++) {
      random -= weights[i];
      if (random <= 0) return personalities[i];
    }

    return 'balanced';
  }

  // Select modules based on personality
  private selectModulesForPersonality(
    personality: BotPersonality,
    context?: { recentAttacks?: string[]; playerLoadout?: ModuleType[] }
  ): ModuleType[] {
    let pool: ModuleType[];

    switch (personality) {
      case 'minimalist':
        pool = MODULE_TYPES_BY_CATEGORY.classic;
        break;
      case 'arcade_master':
        pool = MODULE_TYPES_BY_CATEGORY.arcade;
        break;
      case 'puzzle_expert':
        pool = MODULE_TYPES_BY_CATEGORY.puzzle;
        break;
      case 'meta_gamer':
        pool = CURRENT_META_GAMES;
        break;
      case 'trickster':
        // Mix from all categories for surprise
        pool = [
          this.randomFrom(MODULE_TYPES_BY_CATEGORY.classic),
          this.randomFrom(MODULE_TYPES_BY_CATEGORY.arcade),
          this.randomFrom(MODULE_TYPES_BY_CATEGORY.puzzle),
        ];
        return pool;
      case 'chaos':
        // Completely random
        return [
          this.randomFrom(ALL_MODULE_TYPES),
          this.randomFrom(ALL_MODULE_TYPES),
          this.randomFrom(ALL_MODULE_TYPES),
        ];
      default:
        // Balanced - mix categories
        pool = ALL_MODULE_TYPES;
    }

    // Counter-strategy: avoid modules the player uses (they're probably good at those)
    // Note: chaos and trickster return early, so this code only runs for other personalities
    if (context?.playerLoadout) {
      pool = pool.filter(m => !context.playerLoadout!.includes(m));
      if (pool.length < 3) pool = ALL_MODULE_TYPES; // fallback if too filtered
    }

    // Pick 3 unique modules
    const selected: ModuleType[] = [];
    const available = [...pool];

    for (let i = 0; i < 3 && available.length > 0; i++) {
      const idx = Math.floor(Math.random() * available.length);
      selected.push(available[idx]);
      available.splice(idx, 1);
    }

    // Fill with defaults if needed
    while (selected.length < 3) {
      selected.push(this.randomFrom(MODULE_TYPES_BY_CATEGORY.classic));
    }

    return selected;
  }

  // Generate a thematic name based on personality
  private generateName(personality: BotPersonality): string {
    const prefixes: Record<BotPersonality, string[]> = {
      aggressive: ['Brutal', 'Savage', 'Fierce', 'Raging', 'Vicious'],
      defensive: ['Fort', 'Iron', 'Steel', 'Guardian', 'Shield'],
      balanced: ['Sage', 'Wise', 'Steady', 'Neutral', 'Even'],
      trickster: ['Tricky', 'Sly', 'Cunning', 'Devious', 'Shadow'],
      minimalist: ['Simple', 'Basic', 'Clean', 'Pure', 'Minimal'],
      arcade_master: ['Pixel', 'Retro', 'Arcade', 'Classic', 'Game'],
      puzzle_expert: ['Enigma', 'Riddle', 'Logic', 'Cipher', 'Mind'],
      chaos: ['Random', 'Chaos', 'Wild', 'Unpredictable', 'Entropy'],
      meta_gamer: ['Meta', 'Pro', 'Elite', 'Optimal', 'Min-Max'],
    };

    const suffixes = ['Vault', 'Safe', 'Keep', 'Lock', 'Guard', 'Box', 'Haven'];

    const prefix = this.randomFrom(prefixes[personality]);
    const suffix = this.randomFrom(suffixes);
    const number = Math.floor(Math.random() * 999);

    return `${prefix}${suffix}${number}`;
  }

  // Helper: random element from array
  private randomFrom<T>(arr: T[]): T {
    return arr[Math.floor(Math.random() * arr.length)];
  }

  // Generate a complete bot safe using AI strategy
  async generateAIBot(
    playerRating: number,
    context?: { recentAttacks?: string[]; playerLoadout?: ModuleType[] }
  ): Promise<BotSafe> {
    const strategy = await this.generateStrategy(playerRating, context);
    return this.createBotFromStrategy(strategy, playerRating);
  }

  // Create a BotSafe from a strategy
  createBotFromStrategy(strategy: BotStrategy, playerRating: number): BotSafe {
    // Determine difficulty based on preference
    let baseDifficulty: number;
    switch (strategy.difficultyPreference) {
      case 'easy': baseDifficulty = 0.2 + Math.random() * 0.2; break;
      case 'medium': baseDifficulty = 0.35 + Math.random() * 0.25; break;
      case 'hard': baseDifficulty = 0.6 + Math.random() * 0.35; break;
      case 'varied': baseDifficulty = Math.random(); break;
      default: baseDifficulty = 0.4;
    }

    // Determine wealth
    let baseBalance: number;
    switch (strategy.wealthLevel) {
      case 'poor': baseBalance = 200 + Math.random() * 500; break;
      case 'moderate': baseBalance = 700 + Math.random() * 1500; break;
      case 'wealthy': baseBalance = 2000 + Math.random() * 3000; break;
      default: baseBalance = 1000;
    }

    // Create modules from preferred types
    const modules: SecurityModule[] = strategy.preferredModuleTypes.map((type, index) => {
      const config = MODULE_CONFIG[type];
      // Add some variance to difficulty per module
      const variance = strategy.difficultyPreference === 'varied'
        ? (Math.random() - 0.5) * 0.4
        : (Math.random() - 0.5) * 0.15;
      const difficulty = Math.max(0.05, Math.min(0.95, baseDifficulty + variance));

      return {
        id: `${type}-${Date.now()}-${index}`,
        type,
        difficulty,
        weight: config.baseWeight,
        name: config.name,
        description: config.description,
      };
    });

    const loadout: SecurityLoadout = {
      modules,
      effectiveScore: 0,
    };
    loadout.effectiveScore = calculateSecurityScore(loadout);

    const safeBalance = Math.round(baseBalance);
    const securityScore = loadout.effectiveScore;
    const attackFee = calculateAttackFee(safeBalance, securityScore);
    const successProb = calculateSuccessProbability(playerRating, securityScore);

    return {
      id: `ai-bot-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      ownerName: strategy.name,
      safeBalance,
      securityScore,
      securityLoadout: loadout,
      difficultyBand: getDifficultyBand(securityScore),
      lootRange: getLootRange(safeBalance),
      attackFee,
      successChance: getSuccessChanceLabel(successProb),
      lastAttackedAt: null,
      attackCooldownUntil: null,
      // Extended bot info
      personality: strategy.personality,
      tagline: strategy.tagline,
    };
  }

  // Generate multiple AI bots for the feed
  async generateAIBotFeed(
    playerRating: number,
    count: number = 15,
    context?: { recentAttacks?: string[]; playerLoadout?: ModuleType[] }
  ): Promise<BotSafe[]> {
    const bots: BotSafe[] = [];

    for (let i = 0; i < count; i++) {
      const bot = await this.generateAIBot(playerRating, context);
      bots.push(bot);
    }

    // Sort by a mix of factors to keep things interesting
    return bots.sort((a, b) => {
      // Prioritize variety in difficulty
      const diffScore = (a.securityScore + Math.random() * 20) - (b.securityScore + Math.random() * 20);
      return diffScore;
    });
  }
}

// Singleton instance
export const aiBotService = new AIBotService();

// Export for configuration
export function configureAIBots(config: Partial<AIServiceConfig>): void {
  aiBotService.configure(config);
}
